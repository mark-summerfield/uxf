# TODO (0) uxf rs to subcommand API & ditch uxfcmp.rs
# rsclaptest/src/main.rs
# uxf l|lint <infile1> [infile2 .. infileN]
#     f|fmt|format [-l|--lint] [-s|--standalone] [-d|--dropunused]
#          [-r|--replaceimports] [-i|--indent <indent>]
#          [-w|--wrapwidth <wrapwidth>] [-c|--compact]
#          <infile> [outfile] # outfile may be - or =
#     c|compare [-e|--equiv|--equivalent] <file1> <file2>

# TODO (1)
regression.py # TODO delete delete line in compare()
testdata/regression.dat.gz
# TODO create a big 1MB (then gzip) test file.

# TODO (2) Improve uxf.py's ttype def output to properly honour wrap
# width (and only widen if it necessary); (i) with comment; (ii) without
# comment.
#   (i)
#   =#<A comment no matter how short always followed by NL & depth += 1>
#     Name fields....
#   (ii)
#   =Name fields ...

rs/src/bin/uxf.rs
rs/src/bin/uxfcmp.rs # TODO DELETE once new cli is ready + delete from Cargo.toml
rs/src/lib.rs # TODO (4) docs
rs/src/value.rs
rs/src/key.rs
rs/src/list.rs
rs/src/map.rs
rs/src/table.rs
rs/src/tclass.rs
rs/src/field.rs
rs/src/uxf.rs
rs/src/format.rs
rs/src/check.rs
rs/src/util.rs
rs/src/event.rs
rs/src/consts.rs
rs/src/parser/mod.rs
rs/src/parser/parse.rs
rs/src/parser/lexer.rs
rs/src/parser/token.rs
rs/src/pprint/mod.rs
rs/src/pprint/pretty.rs # TODO (3) (then update .gvimrc to use rust uxf)
rs/src/test_utils.rs
rs/tests/test_value.rs
rs/tests/test_list.rs
rs/tests/test_map.rs
rs/tests/test_table.rs
rs/tests/test_tclass.rs
rs/tests/test_field.rs
rs/tests/test_uxf.rs
# rs/check_lexer.py
rs/Cargo.toml # delete default-run once uxfcmp.rs is deleted

rs/README.md
rs/deploy.sh
rs/deploy.bat

py/uxf.py
py/uxfconvert.py
py/uxflint.py
py/uxfcompare.py
py/README.md
py/setup.py
py/pypi.sh
py/t/regression.py
py/t/test_table.py
py/t/test_sqlite.py
py/t/test_errors.py
py/t/test_lints.py
py/t/test_imports.py
py/t/test_merge.py
py/t/test_include.py
py/t/test_use_config.py
py/t/test_editabletuple.py
py/t/test_compare.py
py/t/test_tlm.py
py/t/test_visit.py
py/t/gen.py
py/t/benchmark.py
py/t/util.py
py/eg/README.md
py/eg/visit.py
py/eg/slides.py
py/eg/slides.sld
py/eg/merge.py
py/eg/include.py
py/eg/Config.py
py/eg/Config2.py
py/eg/Tlm.py

README.md

x/x.py
x/xx.py
x/rs/src/main.rs
x/rs/Cargo.toml

misc/epd2uxf.py
misc/md2html.sh
misc/stats.py
misc/test_server.py
misc/fixversion.py

uxf.vim

st.sh

# TODO port tlm to use rust uxf
# NOTE IDEAS:
# - ~/rs/bin/benchmark.rs (use gen.py files so I can compare with py?)
# - try regression.py & benchmark.py with pypy to compare speeds
# - create geo.uxi based on GeoJSON and if successful create:
#   uxfgeo.py <infile.{json,geojson,uxf,uxg}>
#	      <outfile.{json,geojson,uxf,uxg}>
# - article(s) on replacing csv with uxf & ini/json/toml with uxf
# - uxfdiff.py
# - uxfedit (GUI) applications
# - UXF libraries:
#   . for .js use Dart or TypeScript or similar that can output JS?
#   . uxf.cpp (use zig toolchain?) uxf.java uxf.rb ... ?
# - Documentation:
#   . Complete manual with egs and use cases
#	. Part I Preliminaries
#	. Part II Practicalities
#	    Scalars / Collections / Replacing CSV / Replacing INI /
#	    Replacing JSON / Replacing SQLite / Creating Custom UXF Formats
#	. Part III Technicalities
#	    Railroad Diagrams / BNF / Limits (e.g., date/time/numeric;
#	    str and bytes lengths; etc) / Lists / Maps / Tables /
#	    Implementations // Python // Rust? // JS? // ???
#   . Uniform eXchange Format - a 7"x9" PDF book? (see paper notes)
# - Verification suite: create files (valid & invalid UXF etc) &
#   language/library-neutral scripts for validating a UXF processor's
#   conformance.
# - Experiment with using UXF format to store various kinds of data,
#   e.g., typesetting language, spreadsheet, graphics, etc., &
#   equivalents to other formats, e.g., geojson, etc.
# - Language: allow '.' in identifiers (excl. first char)?
# - Python: load(), loads(), etc., accept listclass=List, mapclass=Map,
#   tableclass=Table, & uses these rather than List, Map, and Table, so
#   the user can use their own subclasses
# NOTE Rejected Ideas
# - Elide ttypes: e.g., given =Pair a b
#	[Pair (Pair 1 2) (Pair 3 4)] â†’ [Pair (1 2) (3 4)]
#   redundant because we can rewrite it as this:
#	(Pair 1 2 3 4)
# - Replace yes and no bools with built-in fieldless tables, (Y) (N)
# - Union types.
# - Money type (twelth type), e.g., MONEY ::= '$' REAL; use, say
#   =Money currency:str amount; or, =USD amount, or similar, (where
#   amount could be str or int or real)
# - datetimes with timezones; use, say =DateTime when:datetime tz:str

# vim: syn=yaml
