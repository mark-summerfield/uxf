py/uxf.py
py/uxfconvert.py
# TODO
# - CLI: uxf.py
#
#   --fix-types
#   
#   If set the UXF processor will silently coerce any scalar value that
#   isn't of the given type to the given type (or warn if it can't).
#   Conversion will only be attempted if the value's type and the given
#   type match one of these: any scalar -> str; str -> bool; str -> real;
#   str-> int; str -> datetime; str -> date; int -> real; real -> int.
# 
#   Add test t40.uxf that exercises all these conversions in each of a
#   list, map, and table.
# 
#   --strip-comments
# 
#   Offer this?
#
# - make sure all test files have some nulls (for every typed value),
#   esp. t4, t24, t34
#
# - create tests t50.uxf ... one for every error or warning that uxf.py
#   can produce to ensure they all work & are understandable.
#
# - implement uxf.py _check()
#
# - test uxf to sqlite: t2.uxf t4.uxf t15.uxf t22.uxf t24.uxf t35.uxf
#
# - sqlite_to_uxf
#
# - test sqlite to uxf: t2.sqlite t4.sqlite t15.sqlite (should round trip)
#
# - uxf_to_xml: same tests as JSON for full round trip
#
# - xml_to_uxf: same tests as JSON for full round trip

README.md

t/regression.py

misc/epd2uxf.py
misc/md2html.sh

setup.py
uxf.vim

pypi.sh
st.sh

t/t0.uxf
t/t1.uxf
t/t2.uxf
t/t3.uxf
t/t4.uxf
t/t5.uxf
t/t6.uxf
t/t7.uxf
t/t8.uxf
t/t9.uxf
t/t10.uxf
t/t11.uxf
t/t12.uxf
t/t13.uxf
t/t14.uxf
t/t15.uxf
t/t20.uxf
t/t21.uxf
t/t22.uxf
t/t23.uxf
t/t24.uxf
t/t27.uxf
t/t28.uxf
t/t29.uxf
t/t31.uxf
t/t34.uxf
t/t35.uxf

t/0.csv
t/1.csv
t/2.csv

# TODO (6) UXF libraries
# for .js use Dart or TypeScript or similar that can output JS
# uxf.rs uxf.cpp uxf.java uxf.rb ...

# vim: syn=yaml
